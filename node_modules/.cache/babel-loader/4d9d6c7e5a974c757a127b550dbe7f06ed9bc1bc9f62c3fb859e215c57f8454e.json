{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { isDOM } from \"rc-util/es/Dom/findDOMNode\";\nimport isVisible from \"rc-util/es/Dom/isVisible\";\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getVisibleArea, getWin, toNum } from \"../util\";\nfunction getUnitOffset(size) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var offsetStr = \"\".concat(offset);\n  var cells = offsetStr.match(/^(.*)\\%$/);\n  if (cells) {\n    return size * (parseFloat(cells[1]) / 100);\n  }\n  return parseFloat(offsetStr);\n}\nfunction getNumberOffset(rect, offset) {\n  var _ref = offset || [],\n    _ref2 = _slicedToArray(_ref, 2),\n    offsetX = _ref2[0],\n    offsetY = _ref2[1];\n  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];\n}\nfunction splitPoints() {\n  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return [points[0], points[1]];\n}\nfunction getAlignPoint(rect, points) {\n  var topBottom = points[0];\n  var leftRight = points[1];\n  var x;\n  var y;\n\n  // Top & Bottom\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  }\n\n  // Left & Right\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction reversePoints(points, index) {\n  var reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  return points.map(function (point, i) {\n    if (i === index) {\n      return reverseMap[point] || 'c';\n    }\n    return point;\n  }).join('');\n}\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {\n  var _React$useState = React.useState({\n      ready: false,\n      offsetX: 0,\n      offsetY: 0,\n      offsetR: 0,\n      offsetB: 0,\n      arrowX: 0,\n      arrowY: 0,\n      scaleX: 1,\n      scaleY: 1,\n      align: builtinPlacements[placement] || {}\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    offsetInfo = _React$useState2[0],\n    setOffsetInfo = _React$useState2[1];\n  var alignCountRef = React.useRef(0);\n  var scrollerList = React.useMemo(function () {\n    if (!popupEle) {\n      return [];\n    }\n    return collectScroller(popupEle);\n  }, [popupEle]);\n\n  // ========================= Flip ==========================\n  // We will memo flip info.\n  // If size change to make flip, it will memo the flip info and use it in next align.\n  var prevFlipRef = React.useRef({});\n  var resetFlipCache = function resetFlipCache() {\n    prevFlipRef.current = {};\n  };\n  if (!open) {\n    resetFlipCache();\n  }\n\n  // ========================= Align =========================\n  var onAlign = useEvent(function () {\n    if (popupEle && target && open) {\n      // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n      var getIntersectionVisibleArea = function getIntersectionVisibleArea(offsetX, offsetY) {\n        var area = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : visibleArea;\n        var l = popupRect.x + offsetX;\n        var t = popupRect.y + offsetY;\n        var r = l + popupWidth;\n        var b = t + popupHeight;\n        var visibleL = Math.max(l, area.left);\n        var visibleT = Math.max(t, area.top);\n        var visibleR = Math.min(r, area.right);\n        var visibleB = Math.min(b, area.bottom);\n        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));\n      };\n      var syncNextPopupPosition = function syncNextPopupPosition() {\n        nextPopupY = popupRect.y + nextOffsetY;\n        nextPopupBottom = nextPopupY + popupHeight;\n        nextPopupX = popupRect.x + nextOffsetX;\n        nextPopupRight = nextPopupX + popupWidth;\n      };\n      var _popupElement$parentE, _popupElement$parentE2;\n      var popupElement = popupEle;\n      var doc = popupElement.ownerDocument;\n      var win = getWin(popupElement);\n      var _win$getComputedStyle = win.getComputedStyle(popupElement),\n        width = _win$getComputedStyle.width,\n        height = _win$getComputedStyle.height,\n        popupPosition = _win$getComputedStyle.position;\n      var originLeft = popupElement.style.left;\n      var originTop = popupElement.style.top;\n      var originRight = popupElement.style.right;\n      var originBottom = popupElement.style.bottom;\n      var originOverflow = popupElement.style.overflow;\n\n      // Placement\n      var placementInfo = _objectSpread(_objectSpread({}, builtinPlacements[placement]), popupAlign);\n\n      // placeholder element\n      var placeholderElement = doc.createElement('div');\n      (_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement);\n      placeholderElement.style.left = \"\".concat(popupElement.offsetLeft, \"px\");\n      placeholderElement.style.top = \"\".concat(popupElement.offsetTop, \"px\");\n      placeholderElement.style.position = popupPosition;\n      placeholderElement.style.height = \"\".concat(popupElement.offsetHeight, \"px\");\n      placeholderElement.style.width = \"\".concat(popupElement.offsetWidth, \"px\");\n\n      // Reset first\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n      popupElement.style.right = 'auto';\n      popupElement.style.bottom = 'auto';\n      popupElement.style.overflow = 'hidden';\n\n      // Calculate align style, we should consider `transform` case\n      var targetRect;\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        var rect = target.getBoundingClientRect();\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      var popupRect = popupElement.getBoundingClientRect();\n      var _doc$documentElement = doc.documentElement,\n        clientWidth = _doc$documentElement.clientWidth,\n        clientHeight = _doc$documentElement.clientHeight,\n        scrollWidth = _doc$documentElement.scrollWidth,\n        scrollHeight = _doc$documentElement.scrollHeight,\n        scrollTop = _doc$documentElement.scrollTop,\n        scrollLeft = _doc$documentElement.scrollLeft;\n      var popupHeight = popupRect.height;\n      var popupWidth = popupRect.width;\n      var targetHeight = targetRect.height;\n      var targetWidth = targetRect.width;\n\n      // Get bounding of visible area\n      var visibleRegion = {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      var scrollRegion = {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      };\n      var htmlRegion = placementInfo.htmlRegion;\n      var VISIBLE = 'visible';\n      var VISIBLE_FIRST = 'visibleFirst';\n      if (htmlRegion !== 'scroll' && htmlRegion !== VISIBLE_FIRST) {\n        htmlRegion = VISIBLE;\n      }\n      var isVisibleFirst = htmlRegion === VISIBLE_FIRST;\n      var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);\n      var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);\n      var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;\n\n      // When set to `visibleFirst`,\n      // the check `adjust` logic will use `visibleRegion` for check first.\n      var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;\n\n      // Record right & bottom align data\n      popupElement.style.left = 'auto';\n      popupElement.style.top = 'auto';\n      popupElement.style.right = '0';\n      popupElement.style.bottom = '0';\n      var popupMirrorRect = popupElement.getBoundingClientRect();\n\n      // Reset back\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n      popupElement.style.right = originRight;\n      popupElement.style.bottom = originBottom;\n      popupElement.style.overflow = originOverflow;\n      (_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement);\n\n      // Calculate scale\n      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);\n\n      // No need to align since it's not visible in view\n      if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      }\n\n      // Offset\n      var offset = placementInfo.offset,\n        targetOffset = placementInfo.targetOffset;\n      var _getNumberOffset = getNumberOffset(popupRect, offset),\n        _getNumberOffset2 = _slicedToArray(_getNumberOffset, 2),\n        popupOffsetX = _getNumberOffset2[0],\n        popupOffsetY = _getNumberOffset2[1];\n      var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset),\n        _getNumberOffset4 = _slicedToArray(_getNumberOffset3, 2),\n        targetOffsetX = _getNumberOffset4[0],\n        targetOffsetY = _getNumberOffset4[1];\n      targetRect.x -= targetOffsetX;\n      targetRect.y -= targetOffsetY;\n\n      // Points\n      var _ref3 = placementInfo.points || [],\n        _ref4 = _slicedToArray(_ref3, 2),\n        popupPoint = _ref4[0],\n        targetPoint = _ref4[1];\n      var targetPoints = splitPoints(targetPoint);\n      var popupPoints = splitPoints(popupPoint);\n      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      var popupAlignPoint = getAlignPoint(popupRect, popupPoints);\n\n      // Real align info may not same as origin one\n      var nextAlignInfo = _objectSpread({}, placementInfo);\n\n      // Next Offset\n      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n      var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);\n\n      // As `visibleFirst`, we prepare this for check\n      var originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);\n\n      // ========================== Overflow ===========================\n      var targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      var popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      var targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      var popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      var overflow = placementInfo.overflow || {};\n      var adjustX = overflow.adjustX,\n        adjustY = overflow.adjustY,\n        shiftX = overflow.shiftX,\n        shiftY = overflow.shiftY;\n      var supportAdjust = function supportAdjust(val) {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n        return val >= 0;\n      };\n\n      // Prepare position\n      var nextPopupY;\n      var nextPopupBottom;\n      var nextPopupX;\n      var nextPopupRight;\n      syncNextPopupPosition();\n\n      // >>>>>>>>>> Top & Bottom\n      var needAdjustY = supportAdjust(adjustY);\n      var sameTB = popupPoints[0] === targetPoints[0];\n\n      // Bottom to Top\n      if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {\n        var tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n        var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        var newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.bt = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.bt = false;\n        }\n      }\n\n      // Top to Bottom\n      if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {\n        var _tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          _tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n        var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY);\n        var _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        _newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.tb = true;\n          nextOffsetY = _tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.tb = false;\n        }\n      }\n\n      // >>>>>>>>>> Left & Right\n      var needAdjustX = supportAdjust(adjustX);\n\n      // >>>>> Flip\n      var sameLR = popupPoints[1] === targetPoints[1];\n\n      // Right to Left\n      if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {\n        var tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n        var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n        var _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        _newVisibleRecommendArea2 >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.rl = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.rl = false;\n        }\n      }\n\n      // Left to Right\n      if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {\n        var _tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          _tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n        var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY);\n        var _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        _newVisibleRecommendArea3 >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.lr = true;\n          nextOffsetX = _tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.lr = false;\n        }\n      }\n\n      // ============================ Shift ============================\n      syncNextPopupPosition();\n      var numShiftX = shiftX === true ? 0 : shiftX;\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleRegionArea.left) {\n          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;\n          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;\n          }\n        }\n\n        // Right\n        if (nextPopupRight > visibleRegionArea.right) {\n          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;\n          if (targetRect.x > visibleRegionArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;\n          }\n        }\n      }\n      var numShiftY = shiftY === true ? 0 : shiftY;\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleRegionArea.top) {\n          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;\n\n          // When target if far away from visible area\n          // Stop shift\n          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;\n          }\n        }\n\n        // Bottom\n        if (nextPopupBottom > visibleRegionArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;\n          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;\n          }\n        }\n      }\n\n      // ============================ Arrow ============================\n      // Arrow center align\n      var popupLeft = popupRect.x + nextOffsetX;\n      var popupRight = popupLeft + popupWidth;\n      var popupTop = popupRect.y + nextOffsetY;\n      var popupBottom = popupTop + popupHeight;\n      var targetLeft = targetRect.x;\n      var targetRight = targetLeft + targetWidth;\n      var targetTop = targetRect.y;\n      var targetBottom = targetTop + targetHeight;\n      var maxLeft = Math.max(popupLeft, targetLeft);\n      var minRight = Math.min(popupRight, targetRight);\n      var xCenter = (maxLeft + minRight) / 2;\n      var nextArrowX = xCenter - popupLeft;\n      var maxTop = Math.max(popupTop, targetTop);\n      var minBottom = Math.min(popupBottom, targetBottom);\n      var yCenter = (maxTop + minBottom) / 2;\n      var nextArrowY = yCenter - popupTop;\n      onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo);\n\n      // Additional calculate right & bottom position\n      var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);\n      var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);\n      setOffsetInfo({\n        ready: true,\n        offsetX: nextOffsetX / _scaleX,\n        offsetY: nextOffsetY / _scaleY,\n        offsetR: offsetX4Right / _scaleX,\n        offsetB: offsetY4Bottom / _scaleY,\n        arrowX: nextArrowX / _scaleX,\n        arrowY: nextArrowY / _scaleY,\n        scaleX: _scaleX,\n        scaleY: _scaleY,\n        align: nextAlignInfo\n      });\n    }\n  });\n  var triggerAlign = function triggerAlign() {\n    alignCountRef.current += 1;\n    var id = alignCountRef.current;\n\n    // Merge all align requirement into one frame\n    Promise.resolve().then(function () {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  };\n\n  // Reset ready status when placement & open changed\n  var resetReady = function resetReady() {\n    setOffsetInfo(function (ori) {\n      return _objectSpread(_objectSpread({}, ori), {}, {\n        ready: false\n      });\n    });\n  };\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(function () {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}","map":{"version":3,"names":["_objectSpread","_slicedToArray","isDOM","isVisible","useEvent","useLayoutEffect","React","collectScroller","getVisibleArea","getWin","toNum","getUnitOffset","size","offset","arguments","length","undefined","offsetStr","concat","cells","match","parseFloat","getNumberOffset","rect","_ref","_ref2","offsetX","offsetY","width","height","splitPoints","points","getAlignPoint","topBottom","leftRight","x","y","reversePoints","index","reverseMap","t","b","l","r","map","point","i","join","useAlign","open","popupEle","target","placement","builtinPlacements","popupAlign","onPopupAlign","_React$useState","useState","ready","offsetR","offsetB","arrowX","arrowY","scaleX","scaleY","align","_React$useState2","offsetInfo","setOffsetInfo","alignCountRef","useRef","scrollerList","useMemo","prevFlipRef","resetFlipCache","current","onAlign","getIntersectionVisibleArea","area","visibleArea","popupRect","popupWidth","popupHeight","visibleL","Math","max","left","visibleT","top","visibleR","min","right","visibleB","bottom","syncNextPopupPosition","nextPopupY","nextOffsetY","nextPopupBottom","nextPopupX","nextOffsetX","nextPopupRight","_popupElement$parentE","_popupElement$parentE2","popupElement","doc","ownerDocument","win","_win$getComputedStyle","getComputedStyle","popupPosition","position","originLeft","style","originTop","originRight","originBottom","originOverflow","overflow","placementInfo","placeholderElement","createElement","parentElement","appendChild","offsetLeft","offsetTop","offsetHeight","offsetWidth","targetRect","Array","isArray","getBoundingClientRect","_doc$documentElement","documentElement","clientWidth","clientHeight","scrollWidth","scrollHeight","scrollTop","scrollLeft","targetHeight","targetWidth","visibleRegion","scrollRegion","htmlRegion","VISIBLE","VISIBLE_FIRST","isVisibleFirst","scrollRegionArea","visibleRegionArea","adjustCheckVisibleArea","popupMirrorRect","removeChild","_scaleX","round","_scaleY","targetOffset","_getNumberOffset","_getNumberOffset2","popupOffsetX","popupOffsetY","_getNumberOffset3","_getNumberOffset4","targetOffsetX","targetOffsetY","_ref3","_ref4","popupPoint","targetPoint","targetPoints","popupPoints","targetAlignPoint","popupAlignPoint","nextAlignInfo","originIntersectionVisibleArea","originIntersectionRecommendArea","targetAlignPointTL","popupAlignPointTL","targetAlignPointBR","popupAlignPointBR","adjustX","adjustY","shiftX","shiftY","supportAdjust","val","needAdjustY","sameTB","bt","tmpNextOffsetY","newVisibleArea","newVisibleRecommendArea","tb","_tmpNextOffsetY","_newVisibleArea","_newVisibleRecommendArea","needAdjustX","sameLR","rl","tmpNextOffsetX","_newVisibleArea2","_newVisibleRecommendArea2","lr","_tmpNextOffsetX","_newVisibleArea3","_newVisibleRecommendArea3","numShiftX","numShiftY","popupLeft","popupRight","popupTop","popupBottom","targetLeft","targetRight","targetTop","targetBottom","maxLeft","minRight","xCenter","nextArrowX","maxTop","minBottom","yCenter","nextArrowY","offsetX4Right","offsetY4Bottom","triggerAlign","id","Promise","resolve","then","resetReady","ori"],"sources":["/Users/zhangyanjun/react-project/mail/node_modules/@rc-component/trigger/es/hooks/useAlign.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { isDOM } from \"rc-util/es/Dom/findDOMNode\";\nimport isVisible from \"rc-util/es/Dom/isVisible\";\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getVisibleArea, getWin, toNum } from \"../util\";\nfunction getUnitOffset(size) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var offsetStr = \"\".concat(offset);\n  var cells = offsetStr.match(/^(.*)\\%$/);\n  if (cells) {\n    return size * (parseFloat(cells[1]) / 100);\n  }\n  return parseFloat(offsetStr);\n}\nfunction getNumberOffset(rect, offset) {\n  var _ref = offset || [],\n    _ref2 = _slicedToArray(_ref, 2),\n    offsetX = _ref2[0],\n    offsetY = _ref2[1];\n  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];\n}\nfunction splitPoints() {\n  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return [points[0], points[1]];\n}\nfunction getAlignPoint(rect, points) {\n  var topBottom = points[0];\n  var leftRight = points[1];\n  var x;\n  var y;\n\n  // Top & Bottom\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  }\n\n  // Left & Right\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction reversePoints(points, index) {\n  var reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  return points.map(function (point, i) {\n    if (i === index) {\n      return reverseMap[point] || 'c';\n    }\n    return point;\n  }).join('');\n}\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {\n  var _React$useState = React.useState({\n      ready: false,\n      offsetX: 0,\n      offsetY: 0,\n      offsetR: 0,\n      offsetB: 0,\n      arrowX: 0,\n      arrowY: 0,\n      scaleX: 1,\n      scaleY: 1,\n      align: builtinPlacements[placement] || {}\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    offsetInfo = _React$useState2[0],\n    setOffsetInfo = _React$useState2[1];\n  var alignCountRef = React.useRef(0);\n  var scrollerList = React.useMemo(function () {\n    if (!popupEle) {\n      return [];\n    }\n    return collectScroller(popupEle);\n  }, [popupEle]);\n\n  // ========================= Flip ==========================\n  // We will memo flip info.\n  // If size change to make flip, it will memo the flip info and use it in next align.\n  var prevFlipRef = React.useRef({});\n  var resetFlipCache = function resetFlipCache() {\n    prevFlipRef.current = {};\n  };\n  if (!open) {\n    resetFlipCache();\n  }\n\n  // ========================= Align =========================\n  var onAlign = useEvent(function () {\n    if (popupEle && target && open) {\n      var _popupElement$parentE, _popupElement$parentE2;\n      var popupElement = popupEle;\n      var doc = popupElement.ownerDocument;\n      var win = getWin(popupElement);\n      var _win$getComputedStyle = win.getComputedStyle(popupElement),\n        width = _win$getComputedStyle.width,\n        height = _win$getComputedStyle.height,\n        popupPosition = _win$getComputedStyle.position;\n      var originLeft = popupElement.style.left;\n      var originTop = popupElement.style.top;\n      var originRight = popupElement.style.right;\n      var originBottom = popupElement.style.bottom;\n      var originOverflow = popupElement.style.overflow;\n\n      // Placement\n      var placementInfo = _objectSpread(_objectSpread({}, builtinPlacements[placement]), popupAlign);\n\n      // placeholder element\n      var placeholderElement = doc.createElement('div');\n      (_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement);\n      placeholderElement.style.left = \"\".concat(popupElement.offsetLeft, \"px\");\n      placeholderElement.style.top = \"\".concat(popupElement.offsetTop, \"px\");\n      placeholderElement.style.position = popupPosition;\n      placeholderElement.style.height = \"\".concat(popupElement.offsetHeight, \"px\");\n      placeholderElement.style.width = \"\".concat(popupElement.offsetWidth, \"px\");\n\n      // Reset first\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n      popupElement.style.right = 'auto';\n      popupElement.style.bottom = 'auto';\n      popupElement.style.overflow = 'hidden';\n\n      // Calculate align style, we should consider `transform` case\n      var targetRect;\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        var rect = target.getBoundingClientRect();\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      var popupRect = popupElement.getBoundingClientRect();\n      var _doc$documentElement = doc.documentElement,\n        clientWidth = _doc$documentElement.clientWidth,\n        clientHeight = _doc$documentElement.clientHeight,\n        scrollWidth = _doc$documentElement.scrollWidth,\n        scrollHeight = _doc$documentElement.scrollHeight,\n        scrollTop = _doc$documentElement.scrollTop,\n        scrollLeft = _doc$documentElement.scrollLeft;\n      var popupHeight = popupRect.height;\n      var popupWidth = popupRect.width;\n      var targetHeight = targetRect.height;\n      var targetWidth = targetRect.width;\n\n      // Get bounding of visible area\n      var visibleRegion = {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      var scrollRegion = {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      };\n      var htmlRegion = placementInfo.htmlRegion;\n      var VISIBLE = 'visible';\n      var VISIBLE_FIRST = 'visibleFirst';\n      if (htmlRegion !== 'scroll' && htmlRegion !== VISIBLE_FIRST) {\n        htmlRegion = VISIBLE;\n      }\n      var isVisibleFirst = htmlRegion === VISIBLE_FIRST;\n      var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);\n      var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);\n      var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;\n\n      // When set to `visibleFirst`,\n      // the check `adjust` logic will use `visibleRegion` for check first.\n      var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;\n\n      // Record right & bottom align data\n      popupElement.style.left = 'auto';\n      popupElement.style.top = 'auto';\n      popupElement.style.right = '0';\n      popupElement.style.bottom = '0';\n      var popupMirrorRect = popupElement.getBoundingClientRect();\n\n      // Reset back\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n      popupElement.style.right = originRight;\n      popupElement.style.bottom = originBottom;\n      popupElement.style.overflow = originOverflow;\n      (_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement);\n\n      // Calculate scale\n      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);\n\n      // No need to align since it's not visible in view\n      if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      }\n\n      // Offset\n      var offset = placementInfo.offset,\n        targetOffset = placementInfo.targetOffset;\n      var _getNumberOffset = getNumberOffset(popupRect, offset),\n        _getNumberOffset2 = _slicedToArray(_getNumberOffset, 2),\n        popupOffsetX = _getNumberOffset2[0],\n        popupOffsetY = _getNumberOffset2[1];\n      var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset),\n        _getNumberOffset4 = _slicedToArray(_getNumberOffset3, 2),\n        targetOffsetX = _getNumberOffset4[0],\n        targetOffsetY = _getNumberOffset4[1];\n      targetRect.x -= targetOffsetX;\n      targetRect.y -= targetOffsetY;\n\n      // Points\n      var _ref3 = placementInfo.points || [],\n        _ref4 = _slicedToArray(_ref3, 2),\n        popupPoint = _ref4[0],\n        targetPoint = _ref4[1];\n      var targetPoints = splitPoints(targetPoint);\n      var popupPoints = splitPoints(popupPoint);\n      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      var popupAlignPoint = getAlignPoint(popupRect, popupPoints);\n\n      // Real align info may not same as origin one\n      var nextAlignInfo = _objectSpread({}, placementInfo);\n\n      // Next Offset\n      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n\n      // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n      function getIntersectionVisibleArea(offsetX, offsetY) {\n        var area = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : visibleArea;\n        var l = popupRect.x + offsetX;\n        var t = popupRect.y + offsetY;\n        var r = l + popupWidth;\n        var b = t + popupHeight;\n        var visibleL = Math.max(l, area.left);\n        var visibleT = Math.max(t, area.top);\n        var visibleR = Math.min(r, area.right);\n        var visibleB = Math.min(b, area.bottom);\n        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));\n      }\n      var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);\n\n      // As `visibleFirst`, we prepare this for check\n      var originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);\n\n      // ========================== Overflow ===========================\n      var targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      var popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      var targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      var popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      var overflow = placementInfo.overflow || {};\n      var adjustX = overflow.adjustX,\n        adjustY = overflow.adjustY,\n        shiftX = overflow.shiftX,\n        shiftY = overflow.shiftY;\n      var supportAdjust = function supportAdjust(val) {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n        return val >= 0;\n      };\n\n      // Prepare position\n      var nextPopupY;\n      var nextPopupBottom;\n      var nextPopupX;\n      var nextPopupRight;\n      function syncNextPopupPosition() {\n        nextPopupY = popupRect.y + nextOffsetY;\n        nextPopupBottom = nextPopupY + popupHeight;\n        nextPopupX = popupRect.x + nextOffsetX;\n        nextPopupRight = nextPopupX + popupWidth;\n      }\n      syncNextPopupPosition();\n\n      // >>>>>>>>>> Top & Bottom\n      var needAdjustY = supportAdjust(adjustY);\n      var sameTB = popupPoints[0] === targetPoints[0];\n\n      // Bottom to Top\n      if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {\n        var tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n        var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        var newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.bt = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.bt = false;\n        }\n      }\n\n      // Top to Bottom\n      if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {\n        var _tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          _tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n        var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY);\n        var _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        _newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.tb = true;\n          nextOffsetY = _tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.tb = false;\n        }\n      }\n\n      // >>>>>>>>>> Left & Right\n      var needAdjustX = supportAdjust(adjustX);\n\n      // >>>>> Flip\n      var sameLR = popupPoints[1] === targetPoints[1];\n\n      // Right to Left\n      if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {\n        var tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n        var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n        var _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        _newVisibleRecommendArea2 >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.rl = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.rl = false;\n        }\n      }\n\n      // Left to Right\n      if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {\n        var _tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          _tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n        var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY);\n        var _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        _newVisibleRecommendArea3 >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.lr = true;\n          nextOffsetX = _tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.lr = false;\n        }\n      }\n\n      // ============================ Shift ============================\n      syncNextPopupPosition();\n      var numShiftX = shiftX === true ? 0 : shiftX;\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleRegionArea.left) {\n          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;\n          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;\n          }\n        }\n\n        // Right\n        if (nextPopupRight > visibleRegionArea.right) {\n          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;\n          if (targetRect.x > visibleRegionArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;\n          }\n        }\n      }\n      var numShiftY = shiftY === true ? 0 : shiftY;\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleRegionArea.top) {\n          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;\n\n          // When target if far away from visible area\n          // Stop shift\n          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;\n          }\n        }\n\n        // Bottom\n        if (nextPopupBottom > visibleRegionArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;\n          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;\n          }\n        }\n      }\n\n      // ============================ Arrow ============================\n      // Arrow center align\n      var popupLeft = popupRect.x + nextOffsetX;\n      var popupRight = popupLeft + popupWidth;\n      var popupTop = popupRect.y + nextOffsetY;\n      var popupBottom = popupTop + popupHeight;\n      var targetLeft = targetRect.x;\n      var targetRight = targetLeft + targetWidth;\n      var targetTop = targetRect.y;\n      var targetBottom = targetTop + targetHeight;\n      var maxLeft = Math.max(popupLeft, targetLeft);\n      var minRight = Math.min(popupRight, targetRight);\n      var xCenter = (maxLeft + minRight) / 2;\n      var nextArrowX = xCenter - popupLeft;\n      var maxTop = Math.max(popupTop, targetTop);\n      var minBottom = Math.min(popupBottom, targetBottom);\n      var yCenter = (maxTop + minBottom) / 2;\n      var nextArrowY = yCenter - popupTop;\n      onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo);\n\n      // Additional calculate right & bottom position\n      var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);\n      var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);\n      setOffsetInfo({\n        ready: true,\n        offsetX: nextOffsetX / _scaleX,\n        offsetY: nextOffsetY / _scaleY,\n        offsetR: offsetX4Right / _scaleX,\n        offsetB: offsetY4Bottom / _scaleY,\n        arrowX: nextArrowX / _scaleX,\n        arrowY: nextArrowY / _scaleY,\n        scaleX: _scaleX,\n        scaleY: _scaleY,\n        align: nextAlignInfo\n      });\n    }\n  });\n  var triggerAlign = function triggerAlign() {\n    alignCountRef.current += 1;\n    var id = alignCountRef.current;\n\n    // Merge all align requirement into one frame\n    Promise.resolve().then(function () {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  };\n\n  // Reset ready status when placement & open changed\n  var resetReady = function resetReady() {\n    setOffsetInfo(function (ori) {\n      return _objectSpread(_objectSpread({}, ori), {}, {\n        ready: false\n      });\n    });\n  };\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(function () {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}